{
  "version": 3,
  "sources": ["../../@mysten/sui/src/utils/format.ts", "../../base-x/src/esm/index.js", "../../bs58/src/esm/index.js", "../../@mysten/bcs/src/b58.ts", "../../@mysten/bcs/src/b64.ts", "../../@mysten/bcs/src/hex.ts", "../../@mysten/bcs/src/uleb.ts", "../../@mysten/bcs/src/reader.ts", "../../@mysten/bcs/src/utils.ts", "../../@mysten/bcs/src/writer.ts", "../../@mysten/bcs/src/bcs-type.ts", "../../@mysten/bcs/src/bcs.ts", "../../@mysten/sui/src/utils/sui-types.ts", "../../@mysten/sui/src/utils/suins.ts", "../../@mysten/sui/src/utils/constants.ts", "../../@mysten/sui/src/utils/move-registry.ts", "../../@noble/hashes/src/_assert.ts", "../../@noble/hashes/src/crypto.ts", "../../@noble/hashes/src/utils.ts", "../../@noble/hashes/src/_blake.ts", "../../@noble/hashes/src/_u64.ts", "../../@noble/hashes/src/blake2b.ts", "../../@mysten/sui/src/bcs/type-tag-serializer.ts", "../../@mysten/sui/src/bcs/bcs.ts", "../../@mysten/sui/src/bcs/effects.ts", "../../@mysten/sui/src/bcs/index.ts", "../../@mysten/sui/src/utils/dynamic-fields.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nconst ELLIPSIS = '\\u{2026}';\n\nexport function formatAddress(address: string) {\n\tif (address.length <= 6) {\n\t\treturn address;\n\t}\n\n\tconst offset = address.startsWith('0x') ? 2 : 0;\n\n\treturn `0x${address.slice(offset, offset + 4)}${ELLIPSIS}${address.slice(-4)}`;\n}\n\nexport function formatDigest(digest: string) {\n\t// Use 10 first characters\n\treturn `${digest.slice(0, 10)}${ELLIPSIS}`;\n}\n", "// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  const BASE_MAP = new Uint8Array(256)\n  for (let j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (let i = 0; i < ALPHABET.length; i++) {\n    const x = ALPHABET.charAt(i)\n    const xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  const BASE = ALPHABET.length\n  const LEADER = ALPHABET.charAt(0)\n  const FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  const iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    // eslint-disable-next-line no-empty\n    if (source instanceof Uint8Array) { } else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source)\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n    // Skip & count leading zeroes.\n    let zeroes = 0\n    let length = 0\n    let pbegin = 0\n    const pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n    // Allocate enough space in big-endian base58 representation.\n    const size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    const b58 = new Uint8Array(size)\n    // Process the bytes.\n    while (pbegin !== pend) {\n      let carry = source[pbegin]\n      // Apply \"b58 = b58 * 256 + ch\".\n      let i = 0\n      for (let it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n    // Skip leading zeroes in base58 result.\n    let it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n    // Translate the result into a string.\n    let str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    let psz = 0\n    // Skip and count leading '1's.\n    let zeroes = 0\n    let length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n    // Allocate enough space in big-endian base256 representation.\n    const size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    const b256 = new Uint8Array(size)\n    // Process the characters.\n    while (source[psz]) {\n      // Decode character\n      let carry = BASE_MAP[source.charCodeAt(psz)]\n      // Invalid character\n      if (carry === 255) { return }\n      let i = 0\n      for (let it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n    // Skip leading zeroes in b256.\n    let it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    const vch = new Uint8Array(zeroes + (size - it4))\n    let j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    const buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode,\n    decodeUnsafe,\n    decode\n  }\n}\nexport default base\n", "import basex from 'base-x';\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\nexport default basex(ALPHABET);\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport bs58 from 'bs58';\n\nexport const toBase58 = (buffer: Uint8Array) => bs58.encode(buffer);\nexport const fromBase58 = (str: string) => bs58.decode(str);\n\n/** @deprecated use toBase58 instead */\nexport const toB58 = toBase58;\n\n/** @deprecated use fromBase58 instead */\nexport const fromB58 = fromBase58;\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport function fromBase64(base64String: string): Uint8Array {\n\treturn Uint8Array.from(atob(base64String), (char) => char.charCodeAt(0));\n}\n\nconst CHUNK_SIZE = 8192;\nexport function toBase64(bytes: Uint8Array): string {\n\t// Special-case the simple case for speed's sake.\n\tif (bytes.length < CHUNK_SIZE) {\n\t\treturn btoa(String.fromCharCode(...bytes));\n\t}\n\n\tlet output = '';\n\tfor (var i = 0; i < bytes.length; i += CHUNK_SIZE) {\n\t\tconst chunk = bytes.slice(i, i + CHUNK_SIZE);\n\t\toutput += String.fromCharCode(...chunk);\n\t}\n\n\treturn btoa(output);\n}\n\n/** @deprecated use toBase64 instead */\nexport const toB64 = toBase64;\n\n/** @deprecated use fromBase64 instead */\nexport const fromB64 = fromBase64;\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport function fromHex(hexStr: string): Uint8Array {\n\tconst normalized = hexStr.startsWith('0x') ? hexStr.slice(2) : hexStr;\n\tconst padded = normalized.length % 2 === 0 ? normalized : `0${normalized}}`;\n\tconst intArr = padded.match(/.{2}/g)?.map((byte) => parseInt(byte, 16)) ?? [];\n\n\treturn Uint8Array.from(intArr);\n}\n\nexport function toHex(bytes: Uint8Array): string {\n\treturn bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n\n/** @deprecated use toHex instead */\nexport const toHEX = toHex;\n\n/** @deprecated use fromHex instead */\nexport const fromHEX = fromHex;\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n// Helper utility: write number as an ULEB array.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nexport function ulebEncode(num: number): number[] {\n\tlet arr = [];\n\tlet len = 0;\n\n\tif (num === 0) {\n\t\treturn [0];\n\t}\n\n\twhile (num > 0) {\n\t\tarr[len] = num & 0x7f;\n\t\tif ((num >>= 7)) {\n\t\t\tarr[len] |= 0x80;\n\t\t}\n\t\tlen += 1;\n\t}\n\n\treturn arr;\n}\n\n// Helper utility: decode ULEB as an array of numbers.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nexport function ulebDecode(arr: number[] | Uint8Array): {\n\tvalue: number;\n\tlength: number;\n} {\n\tlet total = 0;\n\tlet shift = 0;\n\tlet len = 0;\n\n\t// eslint-disable-next-line no-constant-condition\n\twhile (true) {\n\t\tlet byte = arr[len];\n\t\tlen += 1;\n\t\ttotal |= (byte & 0x7f) << shift;\n\t\tif ((byte & 0x80) === 0) {\n\t\t\tbreak;\n\t\t}\n\t\tshift += 7;\n\t}\n\n\treturn {\n\t\tvalue: total,\n\t\tlength: len,\n\t};\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ulebDecode } from './uleb.js';\n\n/**\n * Class used for reading BCS data chunk by chunk. Meant to be used\n * by some wrapper, which will make sure that data is valid and is\n * matching the desired format.\n *\n * @example\n * // data for this example is:\n * // { a: u8, b: u32, c: bool, d: u64 }\n *\n * let reader = new BcsReader(\"647f1a060001ffffe7890423c78a050102030405\");\n * let field1 = reader.read8();\n * let field2 = reader.read32();\n * let field3 = reader.read8() === '1'; // bool\n * let field4 = reader.read64();\n * // ....\n *\n * Reading vectors is another deal in bcs. To read a vector, you first need to read\n * its length using {@link readULEB}. Here's an example:\n * @example\n * // data encoded: { field: [1, 2, 3, 4, 5] }\n * let reader = new BcsReader(\"050102030405\");\n * let vec_length = reader.readULEB();\n * let elements = [];\n * for (let i = 0; i < vec_length; i++) {\n *   elements.push(reader.read8());\n * }\n * console.log(elements); // [1,2,3,4,5]\n *\n * @param {String} data HEX-encoded data (serialized BCS)\n */\nexport class BcsReader {\n\tprivate dataView: DataView;\n\tprivate bytePosition: number = 0;\n\n\t/**\n\t * @param {Uint8Array} data Data to use as a buffer.\n\t */\n\tconstructor(data: Uint8Array) {\n\t\tthis.dataView = new DataView(data.buffer);\n\t}\n\t/**\n\t * Shift current cursor position by `bytes`.\n\t *\n\t * @param {Number} bytes Number of bytes to\n\t * @returns {this} Self for possible chaining.\n\t */\n\tshift(bytes: number) {\n\t\tthis.bytePosition += bytes;\n\t\treturn this;\n\t}\n\t/**\n\t * Read U8 value from the buffer and shift cursor by 1.\n\t * @returns\n\t */\n\tread8(): number {\n\t\tlet value = this.dataView.getUint8(this.bytePosition);\n\t\tthis.shift(1);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U16 value from the buffer and shift cursor by 2.\n\t * @returns\n\t */\n\tread16(): number {\n\t\tlet value = this.dataView.getUint16(this.bytePosition, true);\n\t\tthis.shift(2);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U32 value from the buffer and shift cursor by 4.\n\t * @returns\n\t */\n\tread32(): number {\n\t\tlet value = this.dataView.getUint32(this.bytePosition, true);\n\t\tthis.shift(4);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U64 value from the buffer and shift cursor by 8.\n\t * @returns\n\t */\n\tread64(): string {\n\t\tlet value1 = this.read32();\n\t\tlet value2 = this.read32();\n\n\t\tlet result = value2.toString(16) + value1.toString(16).padStart(8, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read U128 value from the buffer and shift cursor by 16.\n\t */\n\tread128(): string {\n\t\tlet value1 = BigInt(this.read64());\n\t\tlet value2 = BigInt(this.read64());\n\t\tlet result = value2.toString(16) + value1.toString(16).padStart(16, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read U128 value from the buffer and shift cursor by 32.\n\t * @returns\n\t */\n\tread256(): string {\n\t\tlet value1 = BigInt(this.read128());\n\t\tlet value2 = BigInt(this.read128());\n\t\tlet result = value2.toString(16) + value1.toString(16).padStart(32, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read `num` number of bytes from the buffer and shift cursor by `num`.\n\t * @param num Number of bytes to read.\n\t */\n\treadBytes(num: number): Uint8Array {\n\t\tlet start = this.bytePosition + this.dataView.byteOffset;\n\t\tlet value = new Uint8Array(this.dataView.buffer, start, num);\n\n\t\tthis.shift(num);\n\n\t\treturn value;\n\t}\n\t/**\n\t * Read ULEB value - an integer of varying size. Used for enum indexes and\n\t * vector lengths.\n\t * @returns {Number} The ULEB value.\n\t */\n\treadULEB(): number {\n\t\tlet start = this.bytePosition + this.dataView.byteOffset;\n\t\tlet buffer = new Uint8Array(this.dataView.buffer, start);\n\t\tlet { value, length } = ulebDecode(buffer);\n\n\t\tthis.shift(length);\n\n\t\treturn value;\n\t}\n\t/**\n\t * Read a BCS vector: read a length and then apply function `cb` X times\n\t * where X is the length of the vector, defined as ULEB in BCS bytes.\n\t * @param cb Callback to process elements of vector.\n\t * @returns {Array<Any>} Array of the resulting values, returned by callback.\n\t */\n\treadVec(cb: (reader: BcsReader, i: number, length: number) => any): any[] {\n\t\tlet length = this.readULEB();\n\t\tlet result = [];\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tresult.push(cb(this, i, length));\n\t\t}\n\t\treturn result;\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase58, toBase58 } from './b58.js';\nimport { fromBase64, toBase64 } from './b64.js';\nimport { fromHex, toHex } from './hex.js';\nimport type { Encoding } from './types.js';\n\n/**\n * Encode data with either `hex` or `base64`.\n *\n * @param {Uint8Array} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @return {String} Encoded value.\n */\nexport function encodeStr(data: Uint8Array, encoding: Encoding): string {\n\tswitch (encoding) {\n\t\tcase 'base58':\n\t\t\treturn toBase58(data);\n\t\tcase 'base64':\n\t\t\treturn toBase64(data);\n\t\tcase 'hex':\n\t\t\treturn toHex(data);\n\t\tdefault:\n\t\t\tthrow new Error('Unsupported encoding, supported values are: base64, hex');\n\t}\n}\n\n/**\n * Decode either `base64` or `hex` data.\n *\n * @param {String} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @return {Uint8Array} Encoded value.\n */\nexport function decodeStr(data: string, encoding: Encoding): Uint8Array {\n\tswitch (encoding) {\n\t\tcase 'base58':\n\t\t\treturn fromBase58(data);\n\t\tcase 'base64':\n\t\t\treturn fromBase64(data);\n\t\tcase 'hex':\n\t\t\treturn fromHex(data);\n\t\tdefault:\n\t\t\tthrow new Error('Unsupported encoding, supported values are: base64, hex');\n\t}\n}\n\nexport function splitGenericParameters(\n\tstr: string,\n\tgenericSeparators: [string, string] = ['<', '>'],\n) {\n\tconst [left, right] = genericSeparators;\n\tconst tok = [];\n\tlet word = '';\n\tlet nestedAngleBrackets = 0;\n\n\tfor (let i = 0; i < str.length; i++) {\n\t\tconst char = str[i];\n\t\tif (char === left) {\n\t\t\tnestedAngleBrackets++;\n\t\t}\n\t\tif (char === right) {\n\t\t\tnestedAngleBrackets--;\n\t\t}\n\t\tif (nestedAngleBrackets === 0 && char === ',') {\n\t\t\ttok.push(word.trim());\n\t\t\tword = '';\n\t\t\tcontinue;\n\t\t}\n\t\tword += char;\n\t}\n\n\ttok.push(word.trim());\n\n\treturn tok;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Encoding } from './types.js';\nimport { ulebEncode } from './uleb.js';\nimport { encodeStr } from './utils.js';\n\nexport interface BcsWriterOptions {\n\t/** The initial size (in bytes) of the buffer tht will be allocated */\n\tinitialSize?: number;\n\t/** The maximum size (in bytes) that the buffer is allowed to grow to */\n\tmaxSize?: number;\n\t/** The amount of bytes that will be allocated whenever additional memory is required */\n\tallocateSize?: number;\n}\n\n/**\n * Class used to write BCS data into a buffer. Initializer requires\n * some size of a buffer to init; default value for this buffer is 1KB.\n *\n * Most methods are chainable, so it is possible to write them in one go.\n *\n * @example\n * let serialized = new BcsWriter()\n *   .write8(10)\n *   .write32(1000000)\n *   .write64(10000001000000)\n *   .hex();\n */\n\n/**\n * Set of methods that allows data encoding/decoding as standalone\n * BCS value or a part of a composed structure/vector.\n */\nexport class BcsWriter {\n\tprivate dataView: DataView;\n\tprivate bytePosition: number = 0;\n\tprivate size: number;\n\tprivate maxSize: number;\n\tprivate allocateSize: number;\n\n\tconstructor({\n\t\tinitialSize = 1024,\n\t\tmaxSize = Infinity,\n\t\tallocateSize = 1024,\n\t}: BcsWriterOptions = {}) {\n\t\tthis.size = initialSize;\n\t\tthis.maxSize = maxSize;\n\t\tthis.allocateSize = allocateSize;\n\t\tthis.dataView = new DataView(new ArrayBuffer(initialSize));\n\t}\n\n\tprivate ensureSizeOrGrow(bytes: number) {\n\t\tconst requiredSize = this.bytePosition + bytes;\n\t\tif (requiredSize > this.size) {\n\t\t\tconst nextSize = Math.min(this.maxSize, this.size + this.allocateSize);\n\t\t\tif (requiredSize > nextSize) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthis.size = nextSize;\n\t\t\tconst nextBuffer = new ArrayBuffer(this.size);\n\t\t\tnew Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));\n\t\t\tthis.dataView = new DataView(nextBuffer);\n\t\t}\n\t}\n\n\t/**\n\t * Shift current cursor position by `bytes`.\n\t *\n\t * @param {Number} bytes Number of bytes to\n\t * @returns {this} Self for possible chaining.\n\t */\n\tshift(bytes: number): this {\n\t\tthis.bytePosition += bytes;\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U8 value into a buffer and shift cursor position by 1.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite8(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(1);\n\t\tthis.dataView.setUint8(this.bytePosition, Number(value));\n\t\treturn this.shift(1);\n\t}\n\t/**\n\t * Write a U16 value into a buffer and shift cursor position by 2.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite16(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(2);\n\t\tthis.dataView.setUint16(this.bytePosition, Number(value), true);\n\t\treturn this.shift(2);\n\t}\n\t/**\n\t * Write a U32 value into a buffer and shift cursor position by 4.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite32(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(4);\n\t\tthis.dataView.setUint32(this.bytePosition, Number(value), true);\n\t\treturn this.shift(4);\n\t}\n\t/**\n\t * Write a U64 value into a buffer and shift cursor position by 8.\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite64(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 8).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U128 value into a buffer and shift cursor position by 16.\n\t *\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite128(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 16).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U256 value into a buffer and shift cursor position by 16.\n\t *\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite256(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 32).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a ULEB value into a buffer and shift cursor position by number of bytes\n\t * written.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twriteULEB(value: number): this {\n\t\tulebEncode(value).forEach((el) => this.write8(el));\n\t\treturn this;\n\t}\n\t/**\n\t * Write a vector into a buffer by first writing the vector length and then calling\n\t * a callback on each passed value.\n\t *\n\t * @param {Array<Any>} vector Array of elements to write.\n\t * @param {WriteVecCb} cb Callback to call on each element of the vector.\n\t * @returns {this}\n\t */\n\twriteVec(vector: any[], cb: (writer: BcsWriter, el: any, i: number, len: number) => void): this {\n\t\tthis.writeULEB(vector.length);\n\t\tArray.from(vector).forEach((el, i) => cb(this, el, i, vector.length));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds support for iterations over the object.\n\t * @returns {Uint8Array}\n\t */\n\t*[Symbol.iterator](): Iterator<number, Iterable<number>> {\n\t\tfor (let i = 0; i < this.bytePosition; i++) {\n\t\t\tyield this.dataView.getUint8(i);\n\t\t}\n\t\treturn this.toBytes();\n\t}\n\n\t/**\n\t * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).\n\t * @returns {Uint8Array} Resulting bcs.\n\t */\n\ttoBytes(): Uint8Array {\n\t\treturn new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));\n\t}\n\n\t/**\n\t * Represent data as 'hex' or 'base64'\n\t * @param encoding Encoding to use: 'base64' or 'hex'\n\t */\n\ttoString(encoding: Encoding): string {\n\t\treturn encodeStr(this.toBytes(), encoding);\n\t}\n}\n\nfunction toLittleEndian(bigint: bigint, size: number) {\n\tlet result = new Uint8Array(size);\n\tlet i = 0;\n\twhile (bigint > 0) {\n\t\tresult[i] = Number(bigint % BigInt(256));\n\t\tbigint = bigint / BigInt(256);\n\t\ti += 1;\n\t}\n\treturn result;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase58, toBase58 } from './b58.js';\nimport { fromBase64, toBase64 } from './b64.js';\nimport { fromHex, toHex } from './hex.js';\nimport { BcsReader } from './reader.js';\nimport { ulebEncode } from './uleb.js';\nimport type { BcsWriterOptions } from './writer.js';\nimport { BcsWriter } from './writer.js';\n\nexport interface BcsTypeOptions<T, Input = T> {\n\tname?: string;\n\tvalidate?: (value: Input) => void;\n}\n\nexport class BcsType<T, Input = T> {\n\t$inferType!: T;\n\t$inferInput!: Input;\n\tname: string;\n\tread: (reader: BcsReader) => T;\n\tserializedSize: (value: Input, options?: BcsWriterOptions) => number | null;\n\tvalidate: (value: Input) => void;\n\t#write: (value: Input, writer: BcsWriter) => void;\n\t#serialize: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n\n\tconstructor(\n\t\toptions: {\n\t\t\tname: string;\n\t\t\tread: (reader: BcsReader) => T;\n\t\t\twrite: (value: Input, writer: BcsWriter) => void;\n\t\t\tserialize?: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n\t\t\tserializedSize?: (value: Input) => number | null;\n\t\t\tvalidate?: (value: Input) => void;\n\t\t} & BcsTypeOptions<T, Input>,\n\t) {\n\t\tthis.name = options.name;\n\t\tthis.read = options.read;\n\t\tthis.serializedSize = options.serializedSize ?? (() => null);\n\t\tthis.#write = options.write;\n\t\tthis.#serialize =\n\t\t\toptions.serialize ??\n\t\t\t((value, options) => {\n\t\t\t\tconst writer = new BcsWriter({\n\t\t\t\t\tinitialSize: this.serializedSize(value) ?? undefined,\n\t\t\t\t\t...options,\n\t\t\t\t});\n\t\t\t\tthis.#write(value, writer);\n\t\t\t\treturn writer.toBytes();\n\t\t\t});\n\n\t\tthis.validate = options.validate ?? (() => {});\n\t}\n\n\twrite(value: Input, writer: BcsWriter) {\n\t\tthis.validate(value);\n\t\tthis.#write(value, writer);\n\t}\n\n\tserialize(value: Input, options?: BcsWriterOptions) {\n\t\tthis.validate(value);\n\t\treturn new SerializedBcs(this, this.#serialize(value, options));\n\t}\n\n\tparse(bytes: Uint8Array): T {\n\t\tconst reader = new BcsReader(bytes);\n\t\treturn this.read(reader);\n\t}\n\n\tfromHex(hex: string) {\n\t\treturn this.parse(fromHex(hex));\n\t}\n\n\tfromBase58(b64: string) {\n\t\treturn this.parse(fromBase58(b64));\n\t}\n\n\tfromBase64(b64: string) {\n\t\treturn this.parse(fromBase64(b64));\n\t}\n\n\ttransform<T2, Input2>({\n\t\tname,\n\t\tinput,\n\t\toutput,\n\t\tvalidate,\n\t}: {\n\t\tinput: (val: Input2) => Input;\n\t\toutput: (value: T) => T2;\n\t} & BcsTypeOptions<T2, Input2>) {\n\t\treturn new BcsType<T2, Input2>({\n\t\t\tname: name ?? this.name,\n\t\t\tread: (reader) => output(this.read(reader)),\n\t\t\twrite: (value, writer) => this.#write(input(value), writer),\n\t\t\tserializedSize: (value) => this.serializedSize(input(value)),\n\t\t\tserialize: (value, options) => this.#serialize(input(value), options),\n\t\t\tvalidate: (value) => {\n\t\t\t\tvalidate?.(value);\n\t\t\t\tthis.validate(input(value));\n\t\t\t},\n\t\t});\n\t}\n}\n\nconst SERIALIZED_BCS_BRAND = Symbol.for('@mysten/serialized-bcs') as never;\nexport function isSerializedBcs(obj: unknown): obj is SerializedBcs<unknown> {\n\treturn !!obj && typeof obj === 'object' && (obj as any)[SERIALIZED_BCS_BRAND] === true;\n}\n\nexport class SerializedBcs<T, Input = T> {\n\t#schema: BcsType<T, Input>;\n\t#bytes: Uint8Array;\n\n\t// Used to brand SerializedBcs so that they can be identified, even between multiple copies\n\t// of the @mysten/bcs package are installed\n\tget [SERIALIZED_BCS_BRAND]() {\n\t\treturn true;\n\t}\n\n\tconstructor(type: BcsType<T, Input>, schema: Uint8Array) {\n\t\tthis.#schema = type;\n\t\tthis.#bytes = schema;\n\t}\n\n\ttoBytes() {\n\t\treturn this.#bytes;\n\t}\n\n\ttoHex() {\n\t\treturn toHex(this.#bytes);\n\t}\n\n\ttoBase64() {\n\t\treturn toBase64(this.#bytes);\n\t}\n\n\ttoBase58() {\n\t\treturn toBase58(this.#bytes);\n\t}\n\n\tparse() {\n\t\treturn this.#schema.parse(this.#bytes);\n\t}\n}\n\nexport function fixedSizeBcsType<T, Input = T>({\n\tsize,\n\t...options\n}: {\n\tname: string;\n\tsize: number;\n\tread: (reader: BcsReader) => T;\n\twrite: (value: Input, writer: BcsWriter) => void;\n} & BcsTypeOptions<T, Input>) {\n\treturn new BcsType<T, Input>({\n\t\t...options,\n\t\tserializedSize: () => size,\n\t});\n}\n\nexport function uIntBcsType({\n\treadMethod,\n\twriteMethod,\n\t...options\n}: {\n\tname: string;\n\tsize: number;\n\treadMethod: `read${8 | 16 | 32}`;\n\twriteMethod: `write${8 | 16 | 32}`;\n\tmaxValue: number;\n} & BcsTypeOptions<number, number>) {\n\treturn fixedSizeBcsType<number>({\n\t\t...options,\n\t\tread: (reader) => reader[readMethod](),\n\t\twrite: (value, writer) => writer[writeMethod](value),\n\t\tvalidate: (value) => {\n\t\t\tif (value < 0 || value > options.maxValue) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function bigUIntBcsType({\n\treadMethod,\n\twriteMethod,\n\t...options\n}: {\n\tname: string;\n\tsize: number;\n\treadMethod: `read${64 | 128 | 256}`;\n\twriteMethod: `write${64 | 128 | 256}`;\n\tmaxValue: bigint;\n} & BcsTypeOptions<string, string | number | bigint>) {\n\treturn fixedSizeBcsType<string, string | number | bigint>({\n\t\t...options,\n\t\tread: (reader) => reader[readMethod](),\n\t\twrite: (value, writer) => writer[writeMethod](BigInt(value)),\n\t\tvalidate: (val) => {\n\t\t\tconst value = BigInt(val);\n\t\t\tif (value < 0 || value > options.maxValue) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function dynamicSizeBcsType<T, Input = T>({\n\tserialize,\n\t...options\n}: {\n\tname: string;\n\tread: (reader: BcsReader) => T;\n\tserialize: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n} & BcsTypeOptions<T, Input>) {\n\tconst type = new BcsType<T, Input>({\n\t\t...options,\n\t\tserialize,\n\t\twrite: (value, writer) => {\n\t\t\tfor (const byte of type.serialize(value).toBytes()) {\n\t\t\t\twriter.write8(byte);\n\t\t\t}\n\t\t},\n\t});\n\n\treturn type;\n}\n\nexport function stringLikeBcsType({\n\ttoBytes,\n\tfromBytes,\n\t...options\n}: {\n\tname: string;\n\ttoBytes: (value: string) => Uint8Array;\n\tfromBytes: (bytes: Uint8Array) => string;\n\tserializedSize?: (value: string) => number | null;\n} & BcsTypeOptions<string>) {\n\treturn new BcsType<string>({\n\t\t...options,\n\t\tread: (reader) => {\n\t\t\tconst length = reader.readULEB();\n\t\t\tconst bytes = reader.readBytes(length);\n\n\t\t\treturn fromBytes(bytes);\n\t\t},\n\t\twrite: (hex, writer) => {\n\t\t\tconst bytes = toBytes(hex);\n\t\t\twriter.writeULEB(bytes.length);\n\t\t\tfor (let i = 0; i < bytes.length; i++) {\n\t\t\t\twriter.write8(bytes[i]);\n\t\t\t}\n\t\t},\n\t\tserialize: (value) => {\n\t\t\tconst bytes = toBytes(value);\n\t\t\tconst size = ulebEncode(bytes.length);\n\t\t\tconst result = new Uint8Array(size.length + bytes.length);\n\t\t\tresult.set(size, 0);\n\t\t\tresult.set(bytes, size.length);\n\n\t\t\treturn result;\n\t\t},\n\t\tvalidate: (value) => {\n\t\t\tif (typeof value !== 'string') {\n\t\t\t\tthrow new TypeError(`Invalid ${options.name} value: ${value}. Expected string`);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function lazyBcsType<T, Input>(cb: () => BcsType<T, Input>) {\n\tlet lazyType: BcsType<T, Input> | null = null;\n\tfunction getType() {\n\t\tif (!lazyType) {\n\t\t\tlazyType = cb();\n\t\t}\n\t\treturn lazyType;\n\t}\n\n\treturn new BcsType<T, Input>({\n\t\tname: 'lazy' as never,\n\t\tread: (data) => getType().read(data),\n\t\tserializedSize: (value) => getType().serializedSize(value),\n\t\twrite: (value, writer) => getType().write(value, writer),\n\t\tserialize: (value, options) => getType().serialize(value, options).toBytes(),\n\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsTypeOptions } from './bcs-type.js';\nimport {\n\tBcsType,\n\tbigUIntBcsType,\n\tdynamicSizeBcsType,\n\tfixedSizeBcsType,\n\tlazyBcsType,\n\tstringLikeBcsType,\n\tuIntBcsType,\n} from './bcs-type.js';\nimport type { EnumInputShape, EnumOutputShape } from './types.js';\nimport { ulebEncode } from './uleb.js';\n\nexport const bcs = {\n\t/**\n\t * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.\n\t * @example\n\t * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]\n\t */\n\tu8(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\tname: 'u8',\n\t\t\treadMethod: 'read8',\n\t\t\twriteMethod: 'write8',\n\t\t\tsize: 1,\n\t\t\tmaxValue: 2 ** 8 - 1,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.\n\t * @example\n\t * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]\n\t */\n\tu16(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\tname: 'u16',\n\t\t\treadMethod: 'read16',\n\t\t\twriteMethod: 'write16',\n\t\t\tsize: 2,\n\t\t\tmaxValue: 2 ** 16 - 1,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.\n\t * @example\n\t * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]\n\t */\n\tu32(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\tname: 'u32',\n\t\t\treadMethod: 'read32',\n\t\t\twriteMethod: 'write32',\n\t\t\tsize: 4,\n\t\t\tmaxValue: 2 ** 32 - 1,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.\n\t * @example\n\t * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]\n\t */\n\tu64(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\tname: 'u64',\n\t\t\treadMethod: 'read64',\n\t\t\twriteMethod: 'write64',\n\t\t\tsize: 8,\n\t\t\tmaxValue: 2n ** 64n - 1n,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.\n\t * @example\n\t * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n\t */\n\tu128(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\tname: 'u128',\n\t\t\treadMethod: 'read128',\n\t\t\twriteMethod: 'write128',\n\t\t\tsize: 16,\n\t\t\tmaxValue: 2n ** 128n - 1n,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.\n\t * @example\n\t * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n\t */\n\tu256(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\tname: 'u256',\n\t\t\treadMethod: 'read256',\n\t\t\twriteMethod: 'write256',\n\t\t\tsize: 32,\n\t\t\tmaxValue: 2n ** 256n - 1n,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write boolean values.\n\t * @example\n\t * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]\n\t */\n\tbool(options?: BcsTypeOptions<boolean>) {\n\t\treturn fixedSizeBcsType<boolean>({\n\t\t\tname: 'bool',\n\t\t\tsize: 1,\n\t\t\tread: (reader) => reader.read8() === 1,\n\t\t\twrite: (value, writer) => writer.write8(value ? 1 : 0),\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'boolean') {\n\t\t\t\t\tthrow new TypeError(`Expected boolean, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write unsigned LEB encoded integers\n\t * @example\n\t *\n\t */\n\tuleb128(options?: BcsTypeOptions<number>) {\n\t\treturn dynamicSizeBcsType<number>({\n\t\t\tname: 'uleb128',\n\t\t\tread: (reader) => reader.readULEB(),\n\t\t\tserialize: (value) => {\n\t\t\t\treturn Uint8Array.from(ulebEncode(value));\n\t\t\t},\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a fixed length byte array\n\t * @param size The number of bytes this types represents\n\t * @example\n\t * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]\n\t */\n\tbytes<T extends number>(size: T, options?: BcsTypeOptions<Uint8Array, Iterable<number>>) {\n\t\treturn fixedSizeBcsType<Uint8Array>({\n\t\t\tname: `bytes[${size}]`,\n\t\t\tsize,\n\t\t\tread: (reader) => reader.readBytes(size),\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (let i = 0; i < size; i++) {\n\t\t\t\t\twriter.write8(value[i] ?? 0);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== size) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${size}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded\n\t * @example\n\t * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]\n\t */\n\tstring(options?: BcsTypeOptions<string>) {\n\t\treturn stringLikeBcsType({\n\t\t\tname: 'string',\n\t\t\ttoBytes: (value) => new TextEncoder().encode(value),\n\t\t\tfromBytes: (bytes) => new TextDecoder().decode(bytes),\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that represents a fixed length array of a given type\n\t * @param size The number of elements in the array\n\t * @param type The BcsType of each element in the array\n\t * @example\n\t * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]\n\t */\n\tfixedArray<T, Input>(\n\t\tsize: number,\n\t\ttype: BcsType<T, Input>,\n\t\toptions?: BcsTypeOptions<T[], Iterable<Input> & { length: number }>,\n\t) {\n\t\treturn new BcsType<T[], Iterable<Input> & { length: number }>({\n\t\t\tname: `${type.name}[${size}]`,\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: T[] = new Array(size);\n\t\t\t\tfor (let i = 0; i < size; i++) {\n\t\t\t\t\tresult[i] = type.read(reader);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (const item of value) {\n\t\t\t\t\ttype.write(item, writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== size) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${size}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing an optional value\n\t * @param type The BcsType of the optional value\n\t * @example\n\t * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]\n\t * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]\n\t */\n\toption<T, Input>(type: BcsType<T, Input>) {\n\t\treturn bcs\n\t\t\t.enum(`Option<${type.name}>`, {\n\t\t\t\tNone: null,\n\t\t\t\tSome: type,\n\t\t\t})\n\t\t\t.transform({\n\t\t\t\tinput: (value: Input | null | undefined) => {\n\t\t\t\t\tif (value == null) {\n\t\t\t\t\t\treturn { None: true };\n\t\t\t\t\t}\n\n\t\t\t\t\treturn { Some: value };\n\t\t\t\t},\n\t\t\t\toutput: (value) => {\n\t\t\t\t\tif (value.$kind === 'Some') {\n\t\t\t\t\t\treturn value.Some;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t},\n\t\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a variable length vector of a given type\n\t * @param type The BcsType of each element in the vector\n\t *\n\t * @example\n\t * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]\n\t */\n\tvector<T, Input>(\n\t\ttype: BcsType<T, Input>,\n\t\toptions?: BcsTypeOptions<T[], Iterable<Input> & { length: number }>,\n\t) {\n\t\treturn new BcsType<T[], Iterable<Input> & { length: number }>({\n\t\t\tname: `vector<${type.name}>`,\n\t\t\tread: (reader) => {\n\t\t\t\tconst length = reader.readULEB();\n\t\t\t\tconst result: T[] = new Array(length);\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tresult[i] = type.read(reader);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\twriter.writeULEB(value.length);\n\t\t\t\tfor (const item of value) {\n\t\t\t\t\ttype.write(item, writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a tuple of a given set of types\n\t * @param types The BcsTypes for each element in the tuple\n\t *\n\t * @example\n\t * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])\n\t * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]\n\t */\n\ttuple<const Types extends readonly BcsType<any>[]>(\n\t\ttypes: Types,\n\t\toptions?: BcsTypeOptions<\n\t\t\t{\n\t\t\t\t-readonly [K in keyof Types]: Types[K] extends BcsType<infer T, any> ? T : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof Types]: Types[K] extends BcsType<any, infer T> ? T : never;\n\t\t\t}\n\t\t>,\n\t) {\n\t\treturn new BcsType<\n\t\t\t{\n\t\t\t\t-readonly [K in keyof Types]: Types[K] extends BcsType<infer T, any> ? T : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof Types]: Types[K] extends BcsType<any, infer T> ? T : never;\n\t\t\t}\n\t\t>({\n\t\t\tname: `(${types.map((t) => t.name).join(', ')})`,\n\t\t\tserializedSize: (values) => {\n\t\t\t\tlet total = 0;\n\t\t\t\tfor (let i = 0; i < types.length; i++) {\n\t\t\t\t\tconst size = types[i].serializedSize(values[i]);\n\t\t\t\t\tif (size == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\ttotal += size;\n\t\t\t\t}\n\n\t\t\t\treturn total;\n\t\t\t},\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: unknown[] = [];\n\t\t\t\tfor (const type of types) {\n\t\t\t\t\tresult.push(type.read(reader));\n\t\t\t\t}\n\t\t\t\treturn result as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (let i = 0; i < types.length; i++) {\n\t\t\t\t\ttypes[i].write(value[i], writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!Array.isArray(value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== types.length) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${types.length}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a struct of a given set of fields\n\t * @param name The name of the struct\n\t * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized\n\t *\n\t * @example\n\t * const struct = bcs.struct('MyStruct', {\n\t *  a: bcs.u8(),\n\t *  b: bcs.string(),\n\t * })\n\t * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n\t */\n\tstruct<T extends Record<string, BcsType<any>>>(\n\t\tname: string,\n\t\tfields: T,\n\t\toptions?: Omit<\n\t\t\tBcsTypeOptions<\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t\t\t\t}\n\t\t\t>,\n\t\t\t'name'\n\t\t>,\n\t) {\n\t\tconst canonicalOrder = Object.entries(fields);\n\n\t\treturn new BcsType<\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t\t\t}\n\t\t>({\n\t\t\tname,\n\t\t\tserializedSize: (values) => {\n\t\t\t\tlet total = 0;\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\tconst size = type.serializedSize(values[field]);\n\t\t\t\t\tif (size == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\ttotal += size;\n\t\t\t\t}\n\n\t\t\t\treturn total;\n\t\t\t},\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: Record<string, unknown> = {};\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\tresult[field] = type.read(reader);\n\t\t\t\t}\n\n\t\t\t\treturn result as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\ttype.write(value[field], writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'object' || value == null) {\n\t\t\t\t\tthrow new TypeError(`Expected object, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing an enum of a given set of options\n\t * @param name The name of the enum\n\t * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.\n\t * null can be used to represent a variant with no data.\n\t *\n\t * @example\n\t * const enum = bcs.enum('MyEnum', {\n\t *   A: bcs.u8(),\n\t *   B: bcs.string(),\n\t *   C: null,\n\t * })\n\t * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]\n\t * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n\t * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]\n\t */\n\tenum<T extends Record<string, BcsType<any> | null>>(\n\t\tname: string,\n\t\tvalues: T,\n\t\toptions?: Omit<\n\t\t\tBcsTypeOptions<\n\t\t\t\tEnumOutputShape<{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true;\n\t\t\t\t}>,\n\t\t\t\tEnumInputShape<{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : boolean | object | null;\n\t\t\t\t}>\n\t\t\t>,\n\t\t\t'name'\n\t\t>,\n\t) {\n\t\tconst canonicalOrder = Object.entries(values as object);\n\t\treturn new BcsType<\n\t\t\tEnumOutputShape<{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true;\n\t\t\t}>,\n\t\t\tEnumInputShape<{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : boolean | object | null;\n\t\t\t}>\n\t\t>({\n\t\t\tname,\n\t\t\tread: (reader) => {\n\t\t\t\tconst index = reader.readULEB();\n\n\t\t\t\tconst enumEntry = canonicalOrder[index];\n\t\t\t\tif (!enumEntry) {\n\t\t\t\t\tthrow new TypeError(`Unknown value ${index} for enum ${name}`);\n\t\t\t\t}\n\n\t\t\t\tconst [kind, type] = enumEntry;\n\n\t\t\t\treturn {\n\t\t\t\t\t[kind]: type?.read(reader) ?? true,\n\t\t\t\t\t$kind: kind,\n\t\t\t\t} as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tconst [name, val] = Object.entries(value).filter(([name]) =>\n\t\t\t\t\tObject.hasOwn(values, name),\n\t\t\t\t)[0];\n\n\t\t\t\tfor (let i = 0; i < canonicalOrder.length; i++) {\n\t\t\t\t\tconst [optionName, optionType] = canonicalOrder[i];\n\t\t\t\t\tif (optionName === name) {\n\t\t\t\t\t\twriter.writeULEB(i);\n\t\t\t\t\t\toptionType?.write(val, writer);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'object' || value == null) {\n\t\t\t\t\tthrow new TypeError(`Expected object, found ${typeof value}`);\n\t\t\t\t}\n\n\t\t\t\tconst keys = Object.keys(value).filter(\n\t\t\t\t\t(k) => value[k] !== undefined && Object.hasOwn(values, k),\n\t\t\t\t);\n\n\t\t\t\tif (keys.length !== 1) {\n\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t`Expected object with one key, but found ${keys.length} for type ${name}}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst [variant] = keys;\n\n\t\t\t\tif (!Object.hasOwn(values, variant)) {\n\t\t\t\t\tthrow new TypeError(`Invalid enum variant ${variant}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a map of a given key and value type\n\t * @param keyType The BcsType of the key\n\t * @param valueType The BcsType of the value\n\t * @example\n\t * const map = bcs.map(bcs.u8(), bcs.string())\n\t * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]\n\t */\n\tmap<K, V, InputK = K, InputV = V>(keyType: BcsType<K, InputK>, valueType: BcsType<V, InputV>) {\n\t\treturn bcs.vector(bcs.tuple([keyType, valueType])).transform({\n\t\t\tname: `Map<${keyType.name}, ${valueType.name}>`,\n\t\t\tinput: (value: Map<InputK, InputV>) => {\n\t\t\t\treturn [...value.entries()];\n\t\t\t},\n\t\t\toutput: (value) => {\n\t\t\t\tconst result = new Map<K, V>();\n\t\t\t\tfor (const [key, val] of value) {\n\t\t\t\t\tresult.set(key, val);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.\n\t * @param cb A callback that returns the BcsType\n\t */\n\tlazy<T extends BcsType<any>>(cb: () => T): T {\n\t\treturn lazyBcsType(cb) as T;\n\t},\n};\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase58, splitGenericParameters } from '@mysten/bcs';\n\nconst TX_DIGEST_LENGTH = 32;\n\n/** Returns whether the tx digest is valid based on the serialization format */\nexport function isValidTransactionDigest(value: string): value is string {\n\ttry {\n\t\tconst buffer = fromBase58(value);\n\t\treturn buffer.length === TX_DIGEST_LENGTH;\n\t} catch (e) {\n\t\treturn false;\n\t}\n}\n\n// TODO - can we automatically sync this with rust length definition?\n// Source of truth is\n// https://github.com/MystenLabs/sui/blob/acb2b97ae21f47600e05b0d28127d88d0725561d/crates/sui-types/src/base_types.rs#L67\n// which uses the Move account address length\n// https://github.com/move-language/move/blob/67ec40dc50c66c34fd73512fcc412f3b68d67235/language/move-core/types/src/account_address.rs#L23 .\n\nexport const SUI_ADDRESS_LENGTH = 32;\nexport function isValidSuiAddress(value: string): value is string {\n\treturn isHex(value) && getHexByteLength(value) === SUI_ADDRESS_LENGTH;\n}\n\nexport function isValidSuiObjectId(value: string): boolean {\n\treturn isValidSuiAddress(value);\n}\n\ntype StructTag = {\n\taddress: string;\n\tmodule: string;\n\tname: string;\n\ttypeParams: (string | StructTag)[];\n};\n\nfunction parseTypeTag(type: string): string | StructTag {\n\tif (!type.includes('::')) return type;\n\n\treturn parseStructTag(type);\n}\n\nexport function parseStructTag(type: string): StructTag {\n\tconst [address, module] = type.split('::');\n\n\tconst rest = type.slice(address.length + module.length + 4);\n\tconst name = rest.includes('<') ? rest.slice(0, rest.indexOf('<')) : rest;\n\tconst typeParams = rest.includes('<')\n\t\t? splitGenericParameters(rest.slice(rest.indexOf('<') + 1, rest.lastIndexOf('>'))).map(\n\t\t\t\t(typeParam) => parseTypeTag(typeParam.trim()),\n\t\t\t)\n\t\t: [];\n\n\treturn {\n\t\taddress: normalizeSuiAddress(address),\n\t\tmodule,\n\t\tname,\n\t\ttypeParams,\n\t};\n}\n\nexport function normalizeStructTag(type: string | StructTag): string {\n\tconst { address, module, name, typeParams } =\n\t\ttypeof type === 'string' ? parseStructTag(type) : type;\n\n\tconst formattedTypeParams =\n\t\ttypeParams?.length > 0\n\t\t\t? `<${typeParams\n\t\t\t\t\t.map((typeParam) =>\n\t\t\t\t\t\ttypeof typeParam === 'string' ? typeParam : normalizeStructTag(typeParam),\n\t\t\t\t\t)\n\t\t\t\t\t.join(',')}>`\n\t\t\t: '';\n\n\treturn `${address}::${module}::${name}${formattedTypeParams}`;\n}\n\n/**\n * Perform the following operations:\n * 1. Make the address lower case\n * 2. Prepend `0x` if the string does not start with `0x`.\n * 3. Add more zeros if the length of the address(excluding `0x`) is less than `SUI_ADDRESS_LENGTH`\n *\n * WARNING: if the address value itself starts with `0x`, e.g., `0x0x`, the default behavior\n * is to treat the first `0x` not as part of the address. The default behavior can be overridden by\n * setting `forceAdd0x` to true\n *\n */\nexport function normalizeSuiAddress(value: string, forceAdd0x: boolean = false): string {\n\tlet address = value.toLowerCase();\n\tif (!forceAdd0x && address.startsWith('0x')) {\n\t\taddress = address.slice(2);\n\t}\n\treturn `0x${address.padStart(SUI_ADDRESS_LENGTH * 2, '0')}`;\n}\n\nexport function normalizeSuiObjectId(value: string, forceAdd0x: boolean = false): string {\n\treturn normalizeSuiAddress(value, forceAdd0x);\n}\n\nfunction isHex(value: string): boolean {\n\treturn /^(0x|0X)?[a-fA-F0-9]+$/.test(value) && value.length % 2 === 0;\n}\n\nfunction getHexByteLength(value: string): number {\n\treturn /^(0x|0X)/.test(value) ? (value.length - 2) / 2 : value.length / 2;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nconst SUI_NS_NAME_REGEX =\n\t/^(?!.*(^(?!@)|[-.@])($|[-.@]))(?:[a-z0-9-]{0,63}(?:\\.[a-z0-9-]{0,63})*)?@[a-z0-9-]{0,63}$/i;\nconst SUI_NS_DOMAIN_REGEX = /^(?!.*(^|[-.])($|[-.]))(?:[a-z0-9-]{0,63}\\.)+sui$/i;\nconst MAX_SUI_NS_NAME_LENGTH = 235;\n\nexport function isValidSuiNSName(name: string): boolean {\n\tif (name.length > MAX_SUI_NS_NAME_LENGTH) {\n\t\treturn false;\n\t}\n\n\tif (name.includes('@')) {\n\t\treturn SUI_NS_NAME_REGEX.test(name);\n\t}\n\n\treturn SUI_NS_DOMAIN_REGEX.test(name);\n}\n\nexport function normalizeSuiNSName(name: string, format: 'at' | 'dot' = 'at'): string {\n\tconst lowerCase = name.toLowerCase();\n\tlet parts;\n\n\tif (lowerCase.includes('@')) {\n\t\tif (!SUI_NS_NAME_REGEX.test(lowerCase)) {\n\t\t\tthrow new Error(`Invalid SuiNS name ${name}`);\n\t\t}\n\t\tconst [labels, domain] = lowerCase.split('@');\n\t\tparts = [...(labels ? labels.split('.') : []), domain];\n\t} else {\n\t\tif (!SUI_NS_DOMAIN_REGEX.test(lowerCase)) {\n\t\t\tthrow new Error(`Invalid SuiNS name ${name}`);\n\t\t}\n\t\tparts = lowerCase.split('.').slice(0, -1);\n\t}\n\n\tif (format === 'dot') {\n\t\treturn `${parts.join('.')}.sui`;\n\t}\n\n\treturn `${parts.slice(0, -1).join('.')}@${parts[parts.length - 1]}`;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { normalizeSuiObjectId } from './sui-types.js';\n\nexport const SUI_DECIMALS = 9;\nexport const MIST_PER_SUI = BigInt(1000000000);\n\nexport const MOVE_STDLIB_ADDRESS = '0x1';\nexport const SUI_FRAMEWORK_ADDRESS = '0x2';\nexport const SUI_SYSTEM_ADDRESS = '0x3';\nexport const SUI_CLOCK_OBJECT_ID = normalizeSuiObjectId('0x6');\nexport const SUI_SYSTEM_MODULE_NAME = 'sui_system';\nexport const SUI_TYPE_ARG = `${SUI_FRAMEWORK_ADDRESS}::sui::SUI`;\nexport const SUI_SYSTEM_STATE_OBJECT_ID: string = normalizeSuiObjectId('0x5');\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { isValidSuiNSName } from './suins.js';\n\n/** The pattern to find an optionally versioned name */\nconst NAME_PATTERN = /^([a-z0-9]+(?:-[a-z0-9]+)*)$/;\n/** The pattern for a valid version number */\nconst VERSION_REGEX = /^\\d+$/;\n/** The maximum size for an app */\nconst MAX_APP_SIZE = 64;\n/** The separator for the name */\nconst NAME_SEPARATOR = '/';\n\nexport const isValidNamedPackage = (name: string): boolean => {\n\tconst parts = name.split(NAME_SEPARATOR);\n\t// The name has to have 2 parts (without-version), or 3 parts (with version).\n\tif (parts.length < 2 || parts.length > 3) return false;\n\n\tconst [org, app, version] = parts; // split by {org} {app} {optional version}\n\n\t// If the version exists, it must be a number.\n\tif (version !== undefined && !VERSION_REGEX.test(version)) return false;\n\t// Check if the org is a valid SuiNS name.\n\tif (!isValidSuiNSName(org)) return false;\n\n\t// Check if the app is a valid name.\n\treturn NAME_PATTERN.test(app) && app.length < MAX_APP_SIZE;\n};\n\n/**\n * Checks if a type contains valid named packages.\n * This DOES NOT check if the type is a valid Move type.\n */\nexport const isValidNamedType = (type: string): boolean => {\n\t// split our type by all possible type delimeters.\n\tconst splitType = type.split(/::|<|>|,/);\n\tfor (const t of splitType) {\n\t\tif (t.includes(NAME_SEPARATOR) && !isValidNamedPackage(t)) return false;\n\t}\n\t// TODO: Add `isValidStructTag` check once it's introduced.\n\treturn true;\n};\n", "function anumber(n: number) {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);\n}\n\n// copied from utils\nfunction isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\nfunction abytes(b: Uint8Array | undefined, ...lengths: number[]) {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\ntype Hash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\nfunction ahash(h: Hash) {\n  if (typeof h !== 'function' || typeof h.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.wrapConstructor');\n  anumber(h.outputLen);\n  anumber(h.blockLen);\n}\n\nfunction aexists(instance: any, checkFinished = true) {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\nfunction aoutput(out: any, instance: any) {\n  abytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('digestInto() expects output buffer of length at least ' + min);\n  }\n}\n\nexport { anumber, anumber as number, abytes, abytes as bytes, ahash, aexists, aoutput };\n\nconst assert = {\n  number: anumber,\n  bytes: abytes,\n  hash: ahash,\n  exists: aexists,\n  output: aoutput,\n};\nexport default assert;\n", "// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// See utils.ts for details.\ndeclare const globalThis: Record<string, any> | undefined;\nexport const crypto =\n  typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n", "/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\nimport { abytes } from './_assert.js';\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n// Cast array to different type\nexport const u8 = (arr: TypedArray) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr: TypedArray) =>\n  new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n\n// Cast array to view\nexport const createView = (arr: TypedArray) =>\n  new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word: number, shift: number) => (word << (32 - shift)) | (word >>> shift);\n// The rotate left (circular left shift) operation for uint32\nexport const rotl = (word: number, shift: number) =>\n  (word << shift) | ((word >>> (32 - shift)) >>> 0);\n\nexport const isLE = /* @__PURE__ */ (() =>\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n// The byte swap operation for uint32\nexport const byteSwap = (word: number) =>\n  ((word << 24) & 0xff000000) |\n  ((word << 8) & 0xff0000) |\n  ((word >>> 8) & 0xff00) |\n  ((word >>> 24) & 0xff);\n// Conditionally byte swap if on a big-endian platform\nexport const byteSwapIfBE = isLE ? (n: number) => n : (n: number) => byteSwap(n);\n\n// In place byte swap for Uint32Array\nexport function byteSwap32(arr: Uint32Array) {\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = byteSwap(arr[i]);\n  }\n}\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => {};\n\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters: number, tick: number, cb: (i: number) => void) {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('utf8ToBytes expected string, got ' + typeof str);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\nexport type Input = Uint8Array | string;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\n// For runtime check if class implements interface\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n    throw new Error('Options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\nexport type CHash = ReturnType<typeof wrapConstructor>;\n\nexport function wrapConstructor<T extends Hash<T>>(hashCons: () => Hash<T>) {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function wrapConstructorWithOpts<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function wrapXOFConstructorWithOpts<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  // Legacy Node.js compatibility\n  if (crypto && typeof crypto.randomBytes === 'function') {\n    return crypto.randomBytes(bytesLength);\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n", "import { anumber, aexists, aoutput } from './_assert.js';\nimport { Hash, Input, toBytes, u32, isLE, byteSwap32, byteSwapIfBE } from './utils.js';\n\n// Blake is based on ChaCha permutation.\n\n// For BLAKE2b, the two extra permutations for rounds 10 and 11 are SIGMA[10..11] = SIGMA[0..1].\n// prettier-ignore\nexport const SIGMA = /* @__PURE__ */ new Uint8Array([\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n  11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,\n  7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,\n  9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,\n  2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,\n  12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11,\n  13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10,\n  6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5,\n  10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0,\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n]);\n\nexport type BlakeOpts = {\n  dkLen?: number;\n  key?: Input;\n  salt?: Input;\n  personalization?: Input;\n};\n\nexport abstract class BLAKE<T extends BLAKE<T>> extends Hash<T> {\n  protected abstract compress(msg: Uint32Array, offset: number, isLast: boolean): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected buffer: Uint8Array;\n  protected buffer32: Uint32Array;\n  protected length: number = 0;\n  protected pos: number = 0;\n  protected finished = false;\n  protected destroyed = false;\n\n  constructor(\n    readonly blockLen: number,\n    public outputLen: number,\n    opts: BlakeOpts = {},\n    keyLen: number,\n    saltLen: number,\n    persLen: number\n  ) {\n    super();\n    anumber(blockLen);\n    anumber(outputLen);\n    anumber(keyLen);\n    if (outputLen < 0 || outputLen > keyLen) throw new Error('outputLen bigger than keyLen');\n    if (opts.key !== undefined && (opts.key.length < 1 || opts.key.length > keyLen))\n      throw new Error('key length must be undefined or 1..' + keyLen);\n    if (opts.salt !== undefined && opts.salt.length !== saltLen)\n      throw new Error('salt must be undefined or ' + saltLen);\n    if (opts.personalization !== undefined && opts.personalization.length !== persLen)\n      throw new Error('personalization must be undefined or ' + persLen);\n    this.buffer = new Uint8Array(blockLen);\n    this.buffer32 = u32(this.buffer);\n  }\n  update(data: Input) {\n    aexists(this);\n    // Main difference with other hashes: there is flag for last block,\n    // so we cannot process current block before we know that there\n    // is the next one. This significantly complicates logic and reduces ability\n    // to do zero-copy processing\n    const { blockLen, buffer, buffer32 } = this;\n    data = toBytes(data);\n    const len = data.length;\n    const offset = data.byteOffset;\n    const buf = data.buffer;\n    for (let pos = 0; pos < len; ) {\n      // If buffer is full and we still have input (don't process last block, same as blake2s)\n      if (this.pos === blockLen) {\n        if (!isLE) byteSwap32(buffer32);\n        this.compress(buffer32, 0, false);\n        if (!isLE) byteSwap32(buffer32);\n        this.pos = 0;\n      }\n      const take = Math.min(blockLen - this.pos, len - pos);\n      const dataOffset = offset + pos;\n      // full block && aligned to 4 bytes && not last in input\n      if (take === blockLen && !(dataOffset % 4) && pos + take < len) {\n        const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));\n        if (!isLE) byteSwap32(data32);\n        for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {\n          this.length += blockLen;\n          this.compress(data32, pos32, false);\n        }\n        if (!isLE) byteSwap32(data32);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      this.length += take;\n      pos += take;\n    }\n    return this;\n  }\n  digestInto(out: Uint8Array) {\n    aexists(this);\n    aoutput(out, this);\n    const { pos, buffer32 } = this;\n    this.finished = true;\n    // Padding\n    this.buffer.subarray(pos).fill(0);\n    if (!isLE) byteSwap32(buffer32);\n    this.compress(buffer32, 0, true);\n    if (!isLE) byteSwap32(buffer32);\n    const out32 = u32(out);\n    this.get().forEach((v, i) => (out32[i] = byteSwapIfBE(v)));\n  }\n  digest() {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    const { buffer, length, finished, destroyed, outputLen, pos } = this;\n    to ||= new (this.constructor as any)({ dkLen: outputLen }) as T;\n    to.set(...this.get());\n    to.length = length;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    to.outputLen = outputLen;\n    to.buffer.set(buffer);\n    to.pos = pos;\n    return to;\n  }\n}\n", "const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n\n// BigUint64Array is too slow as per 2024, so we implement it using Uint32Array.\n// TODO: re-check https://issues.chromium.org/issues/42212588\n\nfunction fromBig(n: bigint, le = false) {\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\n\nfunction split(lst: bigint[], le = false) {\n  let Ah = new Uint32Array(lst.length);\n  let Al = new Uint32Array(lst.length);\n  for (let i = 0; i < lst.length; i++) {\n    const { h, l } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\n\nconst toBig = (h: number, l: number) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h: number, _l: number, s: number) => h >>> s;\nconst shrSL = (h: number, l: number, s: number) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h: number, l: number, s: number) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h: number, l: number, s: number) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h: number, l: number, s: number) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h: number, l: number, s: number) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h: number, l: number) => l;\nconst rotr32L = (h: number, _l: number) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h: number, l: number, s: number) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h: number, l: number, s: number) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h: number, l: number, s: number) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h: number, l: number, s: number) => (h << (s - 32)) | (l >>> (64 - s));\n\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah: number, Al: number, Bh: number, Bl: number) {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al: number, Bl: number, Cl: number) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number) =>\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number) =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number) =>\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number) =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) =>\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n\n// prettier-ignore\nexport {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\n// prettier-ignore\nconst u64 = {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n", "import { BLAKE, BlakeOpts, SIGMA } from './_blake.js';\nimport u64 from './_u64.js';\nimport { toBytes, u32, wrapConstructorWithOpts, byteSwapIfBE } from './utils.js';\n\n// Same as SHA-512 but LE\n// prettier-ignore\nconst B2B_IV = /* @__PURE__ */ new Uint32Array([\n  0xf3bcc908, 0x6a09e667, 0x84caa73b, 0xbb67ae85, 0xfe94f82b, 0x3c6ef372, 0x5f1d36f1, 0xa54ff53a,\n  0xade682d1, 0x510e527f, 0x2b3e6c1f, 0x9b05688c, 0xfb41bd6b, 0x1f83d9ab, 0x137e2179, 0x5be0cd19\n]);\n// Temporary buffer\nconst BBUF = /* @__PURE__ */ new Uint32Array(32);\n\n// Mixing function G splitted in two halfs\nfunction G1b(a: number, b: number, c: number, d: number, msg: Uint32Array, x: number) {\n  // NOTE: V is LE here\n  const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore\n  let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1]; // prettier-ignore\n  let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1]; // prettier-ignore\n  let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1]; // prettier-ignore\n  let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1]; // prettier-ignore\n  // v[a] = (v[a] + v[b] + x) | 0;\n  let ll = u64.add3L(Al, Bl, Xl);\n  Ah = u64.add3H(ll, Ah, Bh, Xh);\n  Al = ll | 0;\n  // v[d] = rotr(v[d] ^ v[a], 32)\n  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });\n  ({ Dh, Dl } = { Dh: u64.rotr32H(Dh, Dl), Dl: u64.rotr32L(Dh, Dl) });\n  // v[c] = (v[c] + v[d]) | 0;\n  ({ h: Ch, l: Cl } = u64.add(Ch, Cl, Dh, Dl));\n  // v[b] = rotr(v[b] ^ v[c], 24)\n  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });\n  ({ Bh, Bl } = { Bh: u64.rotrSH(Bh, Bl, 24), Bl: u64.rotrSL(Bh, Bl, 24) });\n  (BBUF[2 * a] = Al), (BBUF[2 * a + 1] = Ah);\n  (BBUF[2 * b] = Bl), (BBUF[2 * b + 1] = Bh);\n  (BBUF[2 * c] = Cl), (BBUF[2 * c + 1] = Ch);\n  (BBUF[2 * d] = Dl), (BBUF[2 * d + 1] = Dh);\n}\n\nfunction G2b(a: number, b: number, c: number, d: number, msg: Uint32Array, x: number) {\n  // NOTE: V is LE here\n  const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore\n  let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1]; // prettier-ignore\n  let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1]; // prettier-ignore\n  let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1]; // prettier-ignore\n  let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1]; // prettier-ignore\n  // v[a] = (v[a] + v[b] + x) | 0;\n  let ll = u64.add3L(Al, Bl, Xl);\n  Ah = u64.add3H(ll, Ah, Bh, Xh);\n  Al = ll | 0;\n  // v[d] = rotr(v[d] ^ v[a], 16)\n  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });\n  ({ Dh, Dl } = { Dh: u64.rotrSH(Dh, Dl, 16), Dl: u64.rotrSL(Dh, Dl, 16) });\n  // v[c] = (v[c] + v[d]) | 0;\n  ({ h: Ch, l: Cl } = u64.add(Ch, Cl, Dh, Dl));\n  // v[b] = rotr(v[b] ^ v[c], 63)\n  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });\n  ({ Bh, Bl } = { Bh: u64.rotrBH(Bh, Bl, 63), Bl: u64.rotrBL(Bh, Bl, 63) });\n  (BBUF[2 * a] = Al), (BBUF[2 * a + 1] = Ah);\n  (BBUF[2 * b] = Bl), (BBUF[2 * b + 1] = Bh);\n  (BBUF[2 * c] = Cl), (BBUF[2 * c + 1] = Ch);\n  (BBUF[2 * d] = Dl), (BBUF[2 * d + 1] = Dh);\n}\n\nexport class BLAKE2b extends BLAKE<BLAKE2b> {\n  // Same as SHA-512, but LE\n  private v0l = B2B_IV[0] | 0;\n  private v0h = B2B_IV[1] | 0;\n  private v1l = B2B_IV[2] | 0;\n  private v1h = B2B_IV[3] | 0;\n  private v2l = B2B_IV[4] | 0;\n  private v2h = B2B_IV[5] | 0;\n  private v3l = B2B_IV[6] | 0;\n  private v3h = B2B_IV[7] | 0;\n  private v4l = B2B_IV[8] | 0;\n  private v4h = B2B_IV[9] | 0;\n  private v5l = B2B_IV[10] | 0;\n  private v5h = B2B_IV[11] | 0;\n  private v6l = B2B_IV[12] | 0;\n  private v6h = B2B_IV[13] | 0;\n  private v7l = B2B_IV[14] | 0;\n  private v7h = B2B_IV[15] | 0;\n\n  constructor(opts: BlakeOpts = {}) {\n    super(128, opts.dkLen === undefined ? 64 : opts.dkLen, opts, 64, 16, 16);\n    const keyLength = opts.key ? opts.key.length : 0;\n    this.v0l ^= this.outputLen | (keyLength << 8) | (0x01 << 16) | (0x01 << 24);\n    if (opts.salt) {\n      const salt = u32(toBytes(opts.salt));\n      this.v4l ^= byteSwapIfBE(salt[0]);\n      this.v4h ^= byteSwapIfBE(salt[1]);\n      this.v5l ^= byteSwapIfBE(salt[2]);\n      this.v5h ^= byteSwapIfBE(salt[3]);\n    }\n    if (opts.personalization) {\n      const pers = u32(toBytes(opts.personalization));\n      this.v6l ^= byteSwapIfBE(pers[0]);\n      this.v6h ^= byteSwapIfBE(pers[1]);\n      this.v7l ^= byteSwapIfBE(pers[2]);\n      this.v7h ^= byteSwapIfBE(pers[3]);\n    }\n    if (opts.key) {\n      // Pad to blockLen and update\n      const tmp = new Uint8Array(this.blockLen);\n      tmp.set(toBytes(opts.key));\n      this.update(tmp);\n    }\n  }\n  // prettier-ignore\n  protected get(): [\n    number, number, number, number, number, number, number, number,\n    number, number, number, number, number, number, number, number\n  ] {\n    let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;\n    return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];\n  }\n  // prettier-ignore\n  protected set(\n    v0l: number, v0h: number, v1l: number, v1h: number,\n    v2l: number, v2h: number, v3l: number, v3h: number,\n    v4l: number, v4h: number, v5l: number, v5h: number,\n    v6l: number, v6h: number, v7l: number, v7h: number\n  ) {\n    this.v0l = v0l | 0;\n    this.v0h = v0h | 0;\n    this.v1l = v1l | 0;\n    this.v1h = v1h | 0;\n    this.v2l = v2l | 0;\n    this.v2h = v2h | 0;\n    this.v3l = v3l | 0;\n    this.v3h = v3h | 0;\n    this.v4l = v4l | 0;\n    this.v4h = v4h | 0;\n    this.v5l = v5l | 0;\n    this.v5h = v5h | 0;\n    this.v6l = v6l | 0;\n    this.v6h = v6h | 0;\n    this.v7l = v7l | 0;\n    this.v7h = v7h | 0;\n  }\n  protected compress(msg: Uint32Array, offset: number, isLast: boolean) {\n    this.get().forEach((v, i) => (BBUF[i] = v)); // First half from state.\n    BBUF.set(B2B_IV, 16); // Second half from IV.\n    let { h, l } = u64.fromBig(BigInt(this.length));\n    BBUF[24] = B2B_IV[8] ^ l; // Low word of the offset.\n    BBUF[25] = B2B_IV[9] ^ h; // High word.\n    // Invert all bits for last block\n    if (isLast) {\n      BBUF[28] = ~BBUF[28];\n      BBUF[29] = ~BBUF[29];\n    }\n    let j = 0;\n    const s = SIGMA;\n    for (let i = 0; i < 12; i++) {\n      G1b(0, 4, 8, 12, msg, offset + 2 * s[j++]);\n      G2b(0, 4, 8, 12, msg, offset + 2 * s[j++]);\n      G1b(1, 5, 9, 13, msg, offset + 2 * s[j++]);\n      G2b(1, 5, 9, 13, msg, offset + 2 * s[j++]);\n      G1b(2, 6, 10, 14, msg, offset + 2 * s[j++]);\n      G2b(2, 6, 10, 14, msg, offset + 2 * s[j++]);\n      G1b(3, 7, 11, 15, msg, offset + 2 * s[j++]);\n      G2b(3, 7, 11, 15, msg, offset + 2 * s[j++]);\n\n      G1b(0, 5, 10, 15, msg, offset + 2 * s[j++]);\n      G2b(0, 5, 10, 15, msg, offset + 2 * s[j++]);\n      G1b(1, 6, 11, 12, msg, offset + 2 * s[j++]);\n      G2b(1, 6, 11, 12, msg, offset + 2 * s[j++]);\n      G1b(2, 7, 8, 13, msg, offset + 2 * s[j++]);\n      G2b(2, 7, 8, 13, msg, offset + 2 * s[j++]);\n      G1b(3, 4, 9, 14, msg, offset + 2 * s[j++]);\n      G2b(3, 4, 9, 14, msg, offset + 2 * s[j++]);\n    }\n    this.v0l ^= BBUF[0] ^ BBUF[16];\n    this.v0h ^= BBUF[1] ^ BBUF[17];\n    this.v1l ^= BBUF[2] ^ BBUF[18];\n    this.v1h ^= BBUF[3] ^ BBUF[19];\n    this.v2l ^= BBUF[4] ^ BBUF[20];\n    this.v2h ^= BBUF[5] ^ BBUF[21];\n    this.v3l ^= BBUF[6] ^ BBUF[22];\n    this.v3h ^= BBUF[7] ^ BBUF[23];\n    this.v4l ^= BBUF[8] ^ BBUF[24];\n    this.v4h ^= BBUF[9] ^ BBUF[25];\n    this.v5l ^= BBUF[10] ^ BBUF[26];\n    this.v5h ^= BBUF[11] ^ BBUF[27];\n    this.v6l ^= BBUF[12] ^ BBUF[28];\n    this.v6h ^= BBUF[13] ^ BBUF[29];\n    this.v7l ^= BBUF[14] ^ BBUF[30];\n    this.v7h ^= BBUF[15] ^ BBUF[31];\n    BBUF.fill(0);\n  }\n  destroy() {\n    this.destroyed = true;\n    this.buffer32.fill(0);\n    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\n\n/**\n * BLAKE2b - optimized for 64-bit platforms. JS doesn't have uint64, so it's slower than BLAKE2s.\n * @param msg - message that would be hashed\n * @param opts - dkLen, key, salt, personalization\n */\nexport const blake2b = /* @__PURE__ */ wrapConstructorWithOpts<BLAKE2b, BlakeOpts>(\n  (opts) => new BLAKE2b(opts)\n);\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { splitGenericParameters } from '@mysten/bcs';\n\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type { TypeTag } from './types.js';\n\nconst VECTOR_REGEX = /^vector<(.+)>$/;\nconst STRUCT_REGEX = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;\n\nexport class TypeTagSerializer {\n\tstatic parseFromStr(str: string, normalizeAddress = false): TypeTag {\n\t\tif (str === 'address') {\n\t\t\treturn { address: null };\n\t\t} else if (str === 'bool') {\n\t\t\treturn { bool: null };\n\t\t} else if (str === 'u8') {\n\t\t\treturn { u8: null };\n\t\t} else if (str === 'u16') {\n\t\t\treturn { u16: null };\n\t\t} else if (str === 'u32') {\n\t\t\treturn { u32: null };\n\t\t} else if (str === 'u64') {\n\t\t\treturn { u64: null };\n\t\t} else if (str === 'u128') {\n\t\t\treturn { u128: null };\n\t\t} else if (str === 'u256') {\n\t\t\treturn { u256: null };\n\t\t} else if (str === 'signer') {\n\t\t\treturn { signer: null };\n\t\t}\n\n\t\tconst vectorMatch = str.match(VECTOR_REGEX);\n\t\tif (vectorMatch) {\n\t\t\treturn {\n\t\t\t\tvector: TypeTagSerializer.parseFromStr(vectorMatch[1], normalizeAddress),\n\t\t\t};\n\t\t}\n\n\t\tconst structMatch = str.match(STRUCT_REGEX);\n\t\tif (structMatch) {\n\t\t\tconst address = normalizeAddress ? normalizeSuiAddress(structMatch[1]) : structMatch[1];\n\t\t\treturn {\n\t\t\t\tstruct: {\n\t\t\t\t\taddress,\n\t\t\t\t\tmodule: structMatch[2],\n\t\t\t\t\tname: structMatch[3],\n\t\t\t\t\ttypeParams:\n\t\t\t\t\t\tstructMatch[5] === undefined\n\t\t\t\t\t\t\t? []\n\t\t\t\t\t\t\t: TypeTagSerializer.parseStructTypeArgs(structMatch[5], normalizeAddress),\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\tthrow new Error(`Encountered unexpected token when parsing type args for ${str}`);\n\t}\n\n\tstatic parseStructTypeArgs(str: string, normalizeAddress = false): TypeTag[] {\n\t\treturn splitGenericParameters(str).map((tok) =>\n\t\t\tTypeTagSerializer.parseFromStr(tok, normalizeAddress),\n\t\t);\n\t}\n\n\tstatic tagToString(tag: TypeTag): string {\n\t\tif ('bool' in tag) {\n\t\t\treturn 'bool';\n\t\t}\n\t\tif ('u8' in tag) {\n\t\t\treturn 'u8';\n\t\t}\n\t\tif ('u16' in tag) {\n\t\t\treturn 'u16';\n\t\t}\n\t\tif ('u32' in tag) {\n\t\t\treturn 'u32';\n\t\t}\n\t\tif ('u64' in tag) {\n\t\t\treturn 'u64';\n\t\t}\n\t\tif ('u128' in tag) {\n\t\t\treturn 'u128';\n\t\t}\n\t\tif ('u256' in tag) {\n\t\t\treturn 'u256';\n\t\t}\n\t\tif ('address' in tag) {\n\t\t\treturn 'address';\n\t\t}\n\t\tif ('signer' in tag) {\n\t\t\treturn 'signer';\n\t\t}\n\t\tif ('vector' in tag) {\n\t\t\treturn `vector<${TypeTagSerializer.tagToString(tag.vector)}>`;\n\t\t}\n\t\tif ('struct' in tag) {\n\t\t\tconst struct = tag.struct;\n\t\t\tconst typeParams = struct.typeParams.map(TypeTagSerializer.tagToString).join(', ');\n\t\t\treturn `${struct.address}::${struct.module}::${struct.name}${\n\t\t\t\ttypeParams ? `<${typeParams}>` : ''\n\t\t\t}`;\n\t\t}\n\t\tthrow new Error('Invalid TypeTag');\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsType, BcsTypeOptions } from '@mysten/bcs';\nimport { bcs, fromBase58, fromBase64, fromHex, toBase58, toBase64, toHex } from '@mysten/bcs';\n\nimport { isValidSuiAddress, normalizeSuiAddress, SUI_ADDRESS_LENGTH } from '../utils/sui-types.js';\nimport { TypeTagSerializer } from './type-tag-serializer.js';\nimport type { TypeTag as TypeTagType } from './types.js';\n\nfunction unsafe_u64(options?: BcsTypeOptions<number>) {\n\treturn bcs\n\t\t.u64({\n\t\t\tname: 'unsafe_u64',\n\t\t\t...(options as object),\n\t\t})\n\t\t.transform({\n\t\t\tinput: (val: number | string) => val,\n\t\t\toutput: (val) => Number(val),\n\t\t});\n}\n\nfunction optionEnum<T extends BcsType<any, any>>(type: T) {\n\treturn bcs.enum('Option', {\n\t\tNone: null,\n\t\tSome: type,\n\t});\n}\n\nexport const Address = bcs.bytes(SUI_ADDRESS_LENGTH).transform({\n\tvalidate: (val) => {\n\t\tconst address = typeof val === 'string' ? val : toHex(val);\n\t\tif (!address || !isValidSuiAddress(normalizeSuiAddress(address))) {\n\t\t\tthrow new Error(`Invalid Sui address ${address}`);\n\t\t}\n\t},\n\tinput: (val: string | Uint8Array) =>\n\t\ttypeof val === 'string' ? fromHex(normalizeSuiAddress(val)) : val,\n\toutput: (val) => normalizeSuiAddress(toHex(val)),\n});\n\nexport const ObjectDigest = bcs.vector(bcs.u8()).transform({\n\tname: 'ObjectDigest',\n\tinput: (value: string) => fromBase58(value),\n\toutput: (value) => toBase58(new Uint8Array(value)),\n\tvalidate: (value) => {\n\t\tif (fromBase58(value).length !== 32) {\n\t\t\tthrow new Error('ObjectDigest must be 32 bytes');\n\t\t}\n\t},\n});\n\nexport const SuiObjectRef = bcs.struct('SuiObjectRef', {\n\tobjectId: Address,\n\tversion: bcs.u64(),\n\tdigest: ObjectDigest,\n});\n\nexport const SharedObjectRef = bcs.struct('SharedObjectRef', {\n\tobjectId: Address,\n\tinitialSharedVersion: bcs.u64(),\n\tmutable: bcs.bool(),\n});\n\nexport const ObjectArg = bcs.enum('ObjectArg', {\n\tImmOrOwnedObject: SuiObjectRef,\n\tSharedObject: SharedObjectRef,\n\tReceiving: SuiObjectRef,\n});\n\nexport const CallArg = bcs.enum('CallArg', {\n\tPure: bcs.struct('Pure', {\n\t\tbytes: bcs.vector(bcs.u8()).transform({\n\t\t\tinput: (val: string | Uint8Array) => (typeof val === 'string' ? fromBase64(val) : val),\n\t\t\toutput: (val) => toBase64(new Uint8Array(val)),\n\t\t}),\n\t}),\n\tObject: ObjectArg,\n});\n\nconst InnerTypeTag: BcsType<TypeTagType, TypeTagType> = bcs.enum('TypeTag', {\n\tbool: null,\n\tu8: null,\n\tu64: null,\n\tu128: null,\n\taddress: null,\n\tsigner: null,\n\tvector: bcs.lazy(() => InnerTypeTag),\n\tstruct: bcs.lazy(() => StructTag),\n\tu16: null,\n\tu32: null,\n\tu256: null,\n}) as BcsType<TypeTagType>;\n\nexport const TypeTag = InnerTypeTag.transform({\n\tinput: (typeTag: string | TypeTagType) =>\n\t\ttypeof typeTag === 'string' ? TypeTagSerializer.parseFromStr(typeTag, true) : typeTag,\n\toutput: (typeTag: TypeTagType) => TypeTagSerializer.tagToString(typeTag),\n});\n\nexport const Argument = bcs.enum('Argument', {\n\tGasCoin: null,\n\tInput: bcs.u16(),\n\tResult: bcs.u16(),\n\tNestedResult: bcs.tuple([bcs.u16(), bcs.u16()]),\n});\n\nexport const ProgrammableMoveCall = bcs.struct('ProgrammableMoveCall', {\n\tpackage: Address,\n\tmodule: bcs.string(),\n\tfunction: bcs.string(),\n\ttypeArguments: bcs.vector(TypeTag),\n\targuments: bcs.vector(Argument),\n});\n\nexport const Command = bcs.enum('Command', {\n\t/**\n\t * A Move Call - any public Move function can be called via\n\t * this transaction. The results can be used that instant to pass\n\t * into the next transaction.\n\t */\n\tMoveCall: ProgrammableMoveCall,\n\t/**\n\t * Transfer vector of objects to a receiver.\n\t */\n\tTransferObjects: bcs.struct('TransferObjects', {\n\t\tobjects: bcs.vector(Argument),\n\t\taddress: Argument,\n\t}),\n\t// /**\n\t//  * Split `amount` from a `coin`.\n\t//  */\n\tSplitCoins: bcs.struct('SplitCoins', {\n\t\tcoin: Argument,\n\t\tamounts: bcs.vector(Argument),\n\t}),\n\t// /**\n\t//  * Merge Vector of Coins (`sources`) into a `destination`.\n\t//  */\n\tMergeCoins: bcs.struct('MergeCoins', {\n\t\tdestination: Argument,\n\t\tsources: bcs.vector(Argument),\n\t}),\n\t// /**\n\t//  * Publish a Move module.\n\t//  */\n\tPublish: bcs.struct('Publish', {\n\t\tmodules: bcs.vector(\n\t\t\tbcs.vector(bcs.u8()).transform({\n\t\t\t\tinput: (val: string | Uint8Array) => (typeof val === 'string' ? fromBase64(val) : val),\n\t\t\t\toutput: (val) => toBase64(new Uint8Array(val)),\n\t\t\t}),\n\t\t),\n\t\tdependencies: bcs.vector(Address),\n\t}),\n\t// /**\n\t//  * Build a vector of objects using the input arguments.\n\t//  * It is impossible to export construct a `vector<T: key>` otherwise,\n\t//  * so this call serves a utility function.\n\t//  */\n\tMakeMoveVec: bcs.struct('MakeMoveVec', {\n\t\ttype: optionEnum(TypeTag).transform({\n\t\t\tinput: (val: string | null) =>\n\t\t\t\tval === null\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tNone: true,\n\t\t\t\t\t\t}\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tSome: val,\n\t\t\t\t\t\t},\n\t\t\toutput: (val) => val.Some ?? null,\n\t\t}),\n\t\telements: bcs.vector(Argument),\n\t}),\n\tUpgrade: bcs.struct('Upgrade', {\n\t\tmodules: bcs.vector(\n\t\t\tbcs.vector(bcs.u8()).transform({\n\t\t\t\tinput: (val: string | Uint8Array) => (typeof val === 'string' ? fromBase64(val) : val),\n\t\t\t\toutput: (val) => toBase64(new Uint8Array(val)),\n\t\t\t}),\n\t\t),\n\t\tdependencies: bcs.vector(Address),\n\t\tpackage: Address,\n\t\tticket: Argument,\n\t}),\n});\n\nexport const ProgrammableTransaction = bcs.struct('ProgrammableTransaction', {\n\tinputs: bcs.vector(CallArg),\n\tcommands: bcs.vector(Command),\n});\n\nexport const TransactionKind = bcs.enum('TransactionKind', {\n\tProgrammableTransaction: ProgrammableTransaction,\n\tChangeEpoch: null,\n\tGenesis: null,\n\tConsensusCommitPrologue: null,\n});\n\nexport const TransactionExpiration = bcs.enum('TransactionExpiration', {\n\tNone: null,\n\tEpoch: unsafe_u64(),\n});\n\nexport const StructTag = bcs.struct('StructTag', {\n\taddress: Address,\n\tmodule: bcs.string(),\n\tname: bcs.string(),\n\ttypeParams: bcs.vector(InnerTypeTag),\n});\n\nexport const GasData = bcs.struct('GasData', {\n\tpayment: bcs.vector(SuiObjectRef),\n\towner: Address,\n\tprice: bcs.u64(),\n\tbudget: bcs.u64(),\n});\n\nexport const TransactionDataV1 = bcs.struct('TransactionDataV1', {\n\tkind: TransactionKind,\n\tsender: Address,\n\tgasData: GasData,\n\texpiration: TransactionExpiration,\n});\n\nexport const TransactionData = bcs.enum('TransactionData', {\n\tV1: TransactionDataV1,\n});\n\nexport const IntentScope = bcs.enum('IntentScope', {\n\tTransactionData: null,\n\tTransactionEffects: null,\n\tCheckpointSummary: null,\n\tPersonalMessage: null,\n});\n\nexport const IntentVersion = bcs.enum('IntentVersion', {\n\tV0: null,\n});\n\nexport const AppId = bcs.enum('AppId', {\n\tSui: null,\n});\n\nexport const Intent = bcs.struct('Intent', {\n\tscope: IntentScope,\n\tversion: IntentVersion,\n\tappId: AppId,\n});\n\nexport function IntentMessage<T extends BcsType<any>>(T: T) {\n\treturn bcs.struct(`IntentMessage<${T.name}>`, {\n\t\tintent: Intent,\n\t\tvalue: T,\n\t});\n}\n\nexport const CompressedSignature = bcs.enum('CompressedSignature', {\n\tED25519: bcs.fixedArray(64, bcs.u8()),\n\tSecp256k1: bcs.fixedArray(64, bcs.u8()),\n\tSecp256r1: bcs.fixedArray(64, bcs.u8()),\n\tZkLogin: bcs.vector(bcs.u8()),\n});\n\nexport const PublicKey = bcs.enum('PublicKey', {\n\tED25519: bcs.fixedArray(32, bcs.u8()),\n\tSecp256k1: bcs.fixedArray(33, bcs.u8()),\n\tSecp256r1: bcs.fixedArray(33, bcs.u8()),\n\tZkLogin: bcs.vector(bcs.u8()),\n});\n\nexport const MultiSigPkMap = bcs.struct('MultiSigPkMap', {\n\tpubKey: PublicKey,\n\tweight: bcs.u8(),\n});\n\nexport const MultiSigPublicKey = bcs.struct('MultiSigPublicKey', {\n\tpk_map: bcs.vector(MultiSigPkMap),\n\tthreshold: bcs.u16(),\n});\n\nexport const MultiSig = bcs.struct('MultiSig', {\n\tsigs: bcs.vector(CompressedSignature),\n\tbitmap: bcs.u16(),\n\tmultisig_pk: MultiSigPublicKey,\n});\n\nexport const base64String = bcs.vector(bcs.u8()).transform({\n\tinput: (val: string | Uint8Array) => (typeof val === 'string' ? fromBase64(val) : val),\n\toutput: (val) => toBase64(new Uint8Array(val)),\n});\n\nexport const SenderSignedTransaction = bcs.struct('SenderSignedTransaction', {\n\tintentMessage: IntentMessage(TransactionData),\n\ttxSignatures: bcs.vector(base64String),\n});\n\nexport const SenderSignedData = bcs.vector(SenderSignedTransaction, {\n\tname: 'SenderSignedData',\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '@mysten/bcs';\n\nimport { Address, ObjectDigest, SuiObjectRef } from './bcs.js';\n\nconst PackageUpgradeError = bcs.enum('PackageUpgradeError', {\n\tUnableToFetchPackage: bcs.struct('UnableToFetchPackage', { packageId: Address }),\n\tNotAPackage: bcs.struct('NotAPackage', { objectId: Address }),\n\tIncompatibleUpgrade: null,\n\tDigestDoesNotMatch: bcs.struct('DigestDoesNotMatch', { digest: bcs.vector(bcs.u8()) }),\n\tUnknownUpgradePolicy: bcs.struct('UnknownUpgradePolicy', { policy: bcs.u8() }),\n\tPackageIDDoesNotMatch: bcs.struct('PackageIDDoesNotMatch', {\n\t\tpackageId: Address,\n\t\tticketId: Address,\n\t}),\n});\n\nconst ModuleId = bcs.struct('ModuleId', {\n\taddress: Address,\n\tname: bcs.string(),\n});\nconst MoveLocation = bcs.struct('MoveLocation', {\n\tmodule: ModuleId,\n\tfunction: bcs.u16(),\n\tinstruction: bcs.u16(),\n\tfunctionName: bcs.option(bcs.string()),\n});\n\nconst CommandArgumentError = bcs.enum('CommandArgumentError', {\n\tTypeMismatch: null,\n\tInvalidBCSBytes: null,\n\tInvalidUsageOfPureArg: null,\n\tInvalidArgumentToPrivateEntryFunction: null,\n\tIndexOutOfBounds: bcs.struct('IndexOutOfBounds', { idx: bcs.u16() }),\n\tSecondaryIndexOutOfBounds: bcs.struct('SecondaryIndexOutOfBounds', {\n\t\tresultIdx: bcs.u16(),\n\t\tsecondaryIdx: bcs.u16(),\n\t}),\n\tInvalidResultArity: bcs.struct('InvalidResultArity', { resultIdx: bcs.u16() }),\n\tInvalidGasCoinUsage: null,\n\tInvalidValueUsage: null,\n\tInvalidObjectByValue: null,\n\tInvalidObjectByMutRef: null,\n\tSharedObjectOperationNotAllowed: null,\n});\n\nconst TypeArgumentError = bcs.enum('TypeArgumentError', {\n\tTypeNotFound: null,\n\tConstraintNotSatisfied: null,\n});\n\nconst ExecutionFailureStatus = bcs.enum('ExecutionFailureStatus', {\n\tInsufficientGas: null,\n\tInvalidGasObject: null,\n\tInvariantViolation: null,\n\tFeatureNotYetSupported: null,\n\tMoveObjectTooBig: bcs.struct('MoveObjectTooBig', {\n\t\tobjectSize: bcs.u64(),\n\t\tmaxObjectSize: bcs.u64(),\n\t}),\n\tMovePackageTooBig: bcs.struct('MovePackageTooBig', {\n\t\tobjectSize: bcs.u64(),\n\t\tmaxObjectSize: bcs.u64(),\n\t}),\n\tCircularObjectOwnership: bcs.struct('CircularObjectOwnership', { object: Address }),\n\tInsufficientCoinBalance: null,\n\tCoinBalanceOverflow: null,\n\tPublishErrorNonZeroAddress: null,\n\tSuiMoveVerificationError: null,\n\tMovePrimitiveRuntimeError: bcs.option(MoveLocation),\n\tMoveAbort: bcs.tuple([MoveLocation, bcs.u64()]),\n\tVMVerificationOrDeserializationError: null,\n\tVMInvariantViolation: null,\n\tFunctionNotFound: null,\n\tArityMismatch: null,\n\tTypeArityMismatch: null,\n\tNonEntryFunctionInvoked: null,\n\tCommandArgumentError: bcs.struct('CommandArgumentError', {\n\t\targIdx: bcs.u16(),\n\t\tkind: CommandArgumentError,\n\t}),\n\tTypeArgumentError: bcs.struct('TypeArgumentError', {\n\t\targumentIdx: bcs.u16(),\n\t\tkind: TypeArgumentError,\n\t}),\n\tUnusedValueWithoutDrop: bcs.struct('UnusedValueWithoutDrop', {\n\t\tresultIdx: bcs.u16(),\n\t\tsecondaryIdx: bcs.u16(),\n\t}),\n\tInvalidPublicFunctionReturnType: bcs.struct('InvalidPublicFunctionReturnType', {\n\t\tidx: bcs.u16(),\n\t}),\n\tInvalidTransferObject: null,\n\tEffectsTooLarge: bcs.struct('EffectsTooLarge', { currentSize: bcs.u64(), maxSize: bcs.u64() }),\n\tPublishUpgradeMissingDependency: null,\n\tPublishUpgradeDependencyDowngrade: null,\n\tPackageUpgradeError: bcs.struct('PackageUpgradeError', { upgradeError: PackageUpgradeError }),\n\tWrittenObjectsTooLarge: bcs.struct('WrittenObjectsTooLarge', {\n\t\tcurrentSize: bcs.u64(),\n\t\tmaxSize: bcs.u64(),\n\t}),\n\tCertificateDenied: null,\n\tSuiMoveVerificationTimedout: null,\n\tSharedObjectOperationNotAllowed: null,\n\tInputObjectDeleted: null,\n\tExecutionCancelledDueToSharedObjectCongestion: bcs.struct(\n\t\t'ExecutionCancelledDueToSharedObjectCongestion',\n\t\t{\n\t\t\tcongestedObjects: bcs.vector(Address),\n\t\t},\n\t),\n\tAddressDeniedForCoin: bcs.struct('AddressDeniedForCoin', {\n\t\taddress: Address,\n\t\tcoinType: bcs.string(),\n\t}),\n\tCoinTypeGlobalPause: bcs.struct('CoinTypeGlobalPause', { coinType: bcs.string() }),\n\tExecutionCancelledDueToRandomnessUnavailable: null,\n});\n\nconst ExecutionStatus = bcs.enum('ExecutionStatus', {\n\tSuccess: null,\n\tFailed: bcs.struct('ExecutionFailed', {\n\t\terror: ExecutionFailureStatus,\n\t\tcommand: bcs.option(bcs.u64()),\n\t}),\n});\n\nconst GasCostSummary = bcs.struct('GasCostSummary', {\n\tcomputationCost: bcs.u64(),\n\tstorageCost: bcs.u64(),\n\tstorageRebate: bcs.u64(),\n\tnonRefundableStorageFee: bcs.u64(),\n});\n\nconst Owner = bcs.enum('Owner', {\n\tAddressOwner: Address,\n\tObjectOwner: Address,\n\tShared: bcs.struct('Shared', {\n\t\tinitialSharedVersion: bcs.u64(),\n\t}),\n\tImmutable: null,\n});\n\nconst TransactionEffectsV1 = bcs.struct('TransactionEffectsV1', {\n\tstatus: ExecutionStatus,\n\texecutedEpoch: bcs.u64(),\n\tgasUsed: GasCostSummary,\n\tmodifiedAtVersions: bcs.vector(bcs.tuple([Address, bcs.u64()])),\n\tsharedObjects: bcs.vector(SuiObjectRef),\n\ttransactionDigest: ObjectDigest,\n\tcreated: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),\n\tmutated: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),\n\tunwrapped: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),\n\tdeleted: bcs.vector(SuiObjectRef),\n\tunwrappedThenDeleted: bcs.vector(SuiObjectRef),\n\twrapped: bcs.vector(SuiObjectRef),\n\tgasObject: bcs.tuple([SuiObjectRef, Owner]),\n\teventsDigest: bcs.option(ObjectDigest),\n\tdependencies: bcs.vector(ObjectDigest),\n});\n\nconst VersionDigest = bcs.tuple([bcs.u64(), ObjectDigest]);\n\nconst ObjectIn = bcs.enum('ObjectIn', {\n\tNotExist: null,\n\tExist: bcs.tuple([VersionDigest, Owner]),\n});\n\nconst ObjectOut = bcs.enum('ObjectOut', {\n\tNotExist: null,\n\tObjectWrite: bcs.tuple([ObjectDigest, Owner]),\n\tPackageWrite: VersionDigest,\n});\n\nconst IDOperation = bcs.enum('IDOperation', {\n\tNone: null,\n\tCreated: null,\n\tDeleted: null,\n});\n\nconst EffectsObjectChange = bcs.struct('EffectsObjectChange', {\n\tinputState: ObjectIn,\n\toutputState: ObjectOut,\n\tidOperation: IDOperation,\n});\n\nconst UnchangedSharedKind = bcs.enum('UnchangedSharedKind', {\n\tReadOnlyRoot: VersionDigest,\n\tMutateDeleted: bcs.u64(),\n\tReadDeleted: bcs.u64(),\n\tCancelled: bcs.u64(),\n\tPerEpochConfig: null,\n});\n\nconst TransactionEffectsV2 = bcs.struct('TransactionEffectsV2', {\n\tstatus: ExecutionStatus,\n\texecutedEpoch: bcs.u64(),\n\tgasUsed: GasCostSummary,\n\ttransactionDigest: ObjectDigest,\n\tgasObjectIndex: bcs.option(bcs.u32()),\n\teventsDigest: bcs.option(ObjectDigest),\n\tdependencies: bcs.vector(ObjectDigest),\n\tlamportVersion: bcs.u64(),\n\tchangedObjects: bcs.vector(bcs.tuple([Address, EffectsObjectChange])),\n\tunchangedSharedObjects: bcs.vector(bcs.tuple([Address, UnchangedSharedKind])),\n\tauxDataDigest: bcs.option(ObjectDigest),\n});\n\nexport const TransactionEffects = bcs.enum('TransactionEffects', {\n\tV1: TransactionEffectsV1,\n\tV2: TransactionEffectsV2,\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '@mysten/bcs';\n\nimport {\n\tAddress,\n\tAppId,\n\tArgument,\n\tCallArg,\n\tCommand,\n\tCompressedSignature,\n\tGasData,\n\tIntent,\n\tIntentMessage,\n\tIntentScope,\n\tIntentVersion,\n\tMultiSig,\n\tMultiSigPkMap,\n\tMultiSigPublicKey,\n\tObjectArg,\n\tObjectDigest,\n\tProgrammableMoveCall,\n\tProgrammableTransaction,\n\tPublicKey,\n\tSenderSignedData,\n\tSenderSignedTransaction,\n\tSharedObjectRef,\n\tStructTag,\n\tSuiObjectRef,\n\tTransactionData,\n\tTransactionDataV1,\n\tTransactionExpiration,\n\tTransactionKind,\n\tTypeTag,\n} from './bcs.js';\nimport { TransactionEffects } from './effects.js';\n\nexport type { TypeTag } from './types.js';\n\nexport { TypeTagSerializer } from './type-tag-serializer.js';\nexport { BcsType, type BcsTypeOptions } from '@mysten/bcs';\n\nconst suiBcs = {\n\t...bcs,\n\tU8: bcs.u8(),\n\tU16: bcs.u16(),\n\tU32: bcs.u32(),\n\tU64: bcs.u64(),\n\tU128: bcs.u128(),\n\tU256: bcs.u256(),\n\tULEB128: bcs.uleb128(),\n\tBool: bcs.bool(),\n\tString: bcs.string(),\n\tAddress,\n\tAppId,\n\tArgument,\n\tCallArg,\n\tCompressedSignature,\n\tGasData,\n\tIntent,\n\tIntentMessage,\n\tIntentScope,\n\tIntentVersion,\n\tMultiSig,\n\tMultiSigPkMap,\n\tMultiSigPublicKey,\n\tObjectArg,\n\tObjectDigest,\n\tProgrammableMoveCall,\n\tProgrammableTransaction,\n\tPublicKey,\n\tSenderSignedData,\n\tSenderSignedTransaction,\n\tSharedObjectRef,\n\tStructTag,\n\tSuiObjectRef,\n\tCommand,\n\tTransactionData,\n\tTransactionDataV1,\n\tTransactionExpiration,\n\tTransactionKind,\n\tTypeTag,\n\tTransactionEffects,\n};\n\nexport { suiBcs as bcs };\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toHex } from '@mysten/bcs';\nimport { blake2b } from '@noble/hashes/blake2b';\n\nimport type { TypeTag } from '../bcs/bcs.js';\nimport { bcs } from '../bcs/index.js';\n\nexport function deriveDynamicFieldID(\n\tparentId: string,\n\ttypeTag: typeof TypeTag.$inferInput,\n\tkey: Uint8Array,\n) {\n\tconst address = bcs.Address.serialize(parentId).toBytes();\n\tconst tag = bcs.TypeTag.serialize(typeTag).toBytes();\n\tconst keyLength = bcs.u64().serialize(key.length).toBytes();\n\n\tconst hash = blake2b.create({\n\t\tdkLen: 32,\n\t});\n\n\thash.update(new Uint8Array([0xf0]));\n\thash.update(address);\n\thash.update(keyLength);\n\thash.update(key);\n\thash.update(tag);\n\n\treturn `0x${toHex(hash.digest().slice(0, 32))}`;\n}\n"],
  "mappings": "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",
  "names": ["ALPHABET", "esm_default", "esm_default", "base64String", "_BcsType", "options", "toBytes", "name"]
}
